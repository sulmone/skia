<html>
<head>
<div style="height:0">

<div id="cubicOp36u">
  SimplifyNew_Test [cubicOp36u]
{{0,1}, {1,6}, {2,0}, {5,1}},
{{5,1}, {0,1}},
op union
{{0,2}, {1,5}, {1,0}, {6,1}},
{{6,1}, {0,2}},
debugShowCubicIntersection no self intersect {{0,2}, {1,5}, {1,0}, {6,1}}
debugShowCubicLineIntersection wtTs[0]=0 {{0,2}, {1,5}, {1,0}, {6,1}} {{0,2}} wtTs[1]=0.633333333 {{2.2208888888888882,1.6298518518518521}} wtTs[2]=1 {{6,1}} wnTs[0]=1 {{6,1}, {0,2}} wnTs[1]=0.629851852 wnTs[2]=0
debugShowCubicIntersection wtTs[0]=0.281761651 {{0,2}, {1,5}, {1,0}, {6,1}} {{0.74132978521392334,2.9436691246202122}} wtTs[1]=0.83051493 {{3.8593908381032738,0.94043932231067462}} wtTs[2]=0.830515061 {{3.8593922073023155,0.94043907360367252}} wtTs[3]=0.867315861 {{4.2597986321159249,0.88613622701319239}} wtTs[4]=0.867316009 {{4.2598003089230945,0.88613607359480184}} wnTs[0]=0.23811 {{0,1}, {1,6}, {2,0}, {5,1}} wnTs[1]=0.860977989 wnTs[2]=0.860978176 wnTs[3]=0.912837717 wnTs[4]=0.912837923
debugShowCubicLineIntersection wtTs[0]=0.803214143 {{0,2}, {1,5}, {1,0}, {6,1}} {{3.5833594368204942,1}} wnTs[0]=0.283328 {{5,1}, {0,1}}
debugShowCubicLineIntersection wtTs[0]=0.0764226429 {{0,1}, {1,6}, {2,0}, {5,1}} {{0.23016060940409022,1.9616398984326517}} wtTs[1]=0.691654855 {{2.7367211708698314,1.543879804855028}} wnTs[0]=0.96164 {{6,1}, {0,2}} wnTs[1]=0.543879805
debugShowLineIntersection no intersect {{6,1}, {0,2}} {{5,1}, {0,1}}
debugShowCubicIntersection no self intersect {{0,1}, {1,6}, {2,0}, {5,1}}
debugShowCubicLineIntersection wtTs[0]=0 {{0,1}, {1,6}, {2,0}, {5,1}} {{0,1}} wtTs[1]=0.833333333 {{3.6574074074074132,0.99999999999999789}} wtTs[2]=1 {{5,1}} wnTs[0]=1 {{5,1}, {0,1}} wnTs[1]=0.268518519 wnTs[2]=0
debugShowActiveSpans id=3 (0,2 1,5 1,0 6,1) t=0 (0,2) tEnd=0.281761651 other=4 otherT=1 otherIndex=4 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=3 (0,2 1,5 1,0 6,1) t=0.281761651 (0.741329789,2.94366908) tEnd=0.633333333 other=1 otherT=0.238109917 otherIndex=2 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=3 (0,2 1,5 1,0 6,1) t=0.633333333 (2.22088885,1.62985182) tEnd=0.803214143 other=4 otherT=0.629851852 otherIndex=2 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=3 (0,2 1,5 1,0 6,1) t=0.803214143 (3.58335948,1) tEnd=0.83051493 other=2 otherT=0.283328113 otherIndex=2 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=3 (0,2 1,5 1,0 6,1) t=0.83051493 (3.85939074,0.940439343) tEnd=0.830515061 other=1 otherT=0.860977989 otherIndex=5 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=3 (0,2 1,5 1,0 6,1) t=0.830515061 (3.85939217,0.940439045) tEnd=0.867315861 other=1 otherT=0.860978176 otherIndex=6 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=3 (0,2 1,5 1,0 6,1) t=0.867315861 (4.25979853,0.886136234) tEnd=0.867316009 other=1 otherT=0.912837717 otherIndex=7 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=3 (0,2 1,5 1,0 6,1) t=0.867316009 (4.25980043,0.886136055) tEnd=1 other=1 otherT=0.912837923 otherIndex=8 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=4 (6,1 0,2) t=0 (6,1) tEnd=0.543879805 other=3 otherT=1 otherIndex=8 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=4 (6,1 0,2) t=0.543879805 (2.73672128,1.54387975) tEnd=0.629851852 other=1 otherT=0.691654855 otherIndex=3 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=4 (6,1 0,2) t=0.629851852 (2.22088885,1.62985182) tEnd=0.961639898 other=3 otherT=0.633333333 otherIndex=2 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=4 (6,1 0,2) t=0.961639898 (0.230160609,1.96163988) tEnd=1 other=1 otherT=0.0764226429 otherIndex=1 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=1 (0,1 1,6 2,0 5,1) t=0 (0,1) tEnd=0.0764226429 other=2 otherT=1 otherIndex=3 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=1 (0,1 1,6 2,0 5,1) t=0.0764226429 (0.230160609,1.96163988) tEnd=0.238109917 other=4 otherT=0.961639898 otherIndex=3 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=1 (0,1 1,6 2,0 5,1) t=0.238109917 (0.741329789,2.94366908) tEnd=0.691654855 other=3 otherT=0.281761651 otherIndex=1 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=1 (0,1 1,6 2,0 5,1) t=0.691654855 (2.73672128,1.54387975) tEnd=0.833333333 other=4 otherT=0.543879805 otherIndex=1 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=1 (0,1 1,6 2,0 5,1) t=0.833333333 (3.65740752,1) tEnd=0.860977989 other=2 otherT=0.268518519 otherIndex=1 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=1 (0,1 1,6 2,0 5,1) t=0.860977989 (3.85939074,0.940439343) tEnd=0.860978176 other=3 otherT=0.83051493 otherIndex=4 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=1 (0,1 1,6 2,0 5,1) t=0.860978176 (3.85939217,0.940439045) tEnd=0.912837717 other=3 otherT=0.830515061 otherIndex=5 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=1 (0,1 1,6 2,0 5,1) t=0.912837717 (4.25979853,0.886136234) tEnd=0.912837923 other=3 otherT=0.867315861 otherIndex=6 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=1 (0,1 1,6 2,0 5,1) t=0.912837923 (4.25980043,0.886136055) tEnd=1 other=3 otherT=0.867316009 otherIndex=7 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=2 (5,1 0,1) t=0 (5,1) tEnd=0.268518519 other=1 otherT=1 otherIndex=9 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=2 (5,1 0,1) t=0.268518519 (3.65740752,1) tEnd=0.283328113 other=1 otherT=0.833333333 otherIndex=4 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=2 (5,1 0,1) t=0.283328113 (3.58335948,1) tEnd=1 other=3 otherT=0.803214143 otherIndex=3 windSum=? windValue=1 oppValue=0
findTop debugShowSort contourWinding=0 oppContourWinding=0 sign=1
debugShowSort [0] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=1 tEnd=0.867316009 sign=1 windValue=1 windSum=? 0->-1 (max=-1) done=0 tiny=0 opp=0
debugShowSort [1] {{6,1}, {0,2}} tStart=0 tEnd=0.543879805 sign=-1 windValue=1 windSum=? -1->0 (max=-1) done=0 tiny=0 opp=0
findTop xyE=(6,1) xyS=(4.25980043,0.886136055)
findTop dxyE=(15,3) dxyS=(11.3363714,-1.03721189) cross=-49.5672913 bumpsUp=true
markWinding id=3 (0,2 1,5 1,0 6,1) t=0.867316009 [7] (4.25980043,0.886136055) tEnd=1 newWindSum=-1 newOppSum=0 oppSum=? windSum=? windValue=1
markWinding id=4 (6,1 0,2) t=0 [0] (6,1) tEnd=0.543879805 newWindSum=-1 newOppSum=0 oppSum=? windSum=? windValue=1
markWinding id=3 (0,2 1,5 1,0 6,1) t=0.867316009 [7] (4.25980043,0.886136055) tEnd=1 newWindSum=-1 newOppSum=0 oppSum=0 windSum=-1 windValue=1
activeOp op=union miFrom=0 miTo=0 suFrom=1 suTo=0 result=1
findNextOp simple
markDoneBinary id=3 (0,2 1,5 1,0 6,1) t=0.867316009 [7] (4.25980043,0.886136055) tEnd=1 newWindSum=-1 newOppSum=0 oppSum=0 windSum=-1 windValue=1
bridgeOp current id=3 from=(4.25980043,0.886136055) to=(6,1)
path.moveTo(4.25980043,0.886136055);
path.cubicTo(4.76118517,0.840262294, 5.33658028,0.867316008, 6,1);
findNextOp debugShowSort contourWinding=0 oppContourWinding=0 sign=1
debugShowSort [0] {{6,1}, {0,2}} tStart=0.543879805 tEnd=0 sign=1 windValue=1 windSum=-1 0->-1 (max=-1) done=0 tiny=0 opp=0
debugShowSort [1] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.691654855 tEnd=0.833333333 sign=-1 windValue=1 windSum=? 0->1 (max=1) done=0 tiny=0 opp=1
debugShowSort [2] {{6,1}, {0,2}} tStart=0.543879805 tEnd=0.629851852 sign=-1 windValue=1 windSum=? -1->0 (max=-1) done=0 tiny=0 opp=0
debugShowSort [3] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.691654855 tEnd=0.238109917 sign=1 windValue=1 windSum=? 1->0 (max=1) done=0 tiny=0 opp=1
findNextOp firstIndex=[0] sign=1
activeOp op=union miFrom=0 miTo=1 suFrom=1 suTo=1 result=0
markDoneBinary id=1 (0,1 1,6 2,0 5,1) t=0.691654855 [3] (2.73672128,1.54387975) tEnd=0.833333333 newWindSum=1 newOppSum=-1 oppSum=? windSum=? windValue=1
findNextOp chase.append id=1
activeOp op=union miFrom=1 miTo=1 suFrom=1 suTo=0 result=0
markDoneBinary id=4 (6,1 0,2) t=0.543879805 [1] (2.73672128,1.54387975) tEnd=0.629851852 newWindSum=-1 newOppSum=1 oppSum=? windSum=? windValue=1
findNextOp chase.append id=4
activeOp op=union miFrom=1 miTo=0 suFrom=0 suTo=0 result=1
markWinding id=1 (0,1 1,6 2,0 5,1) t=0.238109917 [2] (0.741329789,2.94366908) tEnd=0.691654855 newWindSum=1 newOppSum=0 oppSum=? windSum=? windValue=1
findNextOp chase.append id=1
markDoneBinary id=4 (6,1 0,2Program received signal:  “EXC_BAD_ACCESS”.
) t=0 [0] (6,1) tEnd=0.543879805 newWindSum=-1 newOppSum=0 oppSum=0 windSum=-1 windValue=1
findNextOp from:[4] to:[1] start=3 end=2
bridgeOp current id=4 from=(6,1) to=(2.73672128,1.54387975)
findNextOp debugShowSort contourWinding=0 oppContourWinding=0 sign=-1
debugShowSort [3] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.238109917 tEnd=0.691654855 sign=-1 windValue=1 windSum=1 0->1 (max=1) done=0 tiny=0 opp=0
debugShowSort [0] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.281761651 tEnd=0.633333333 sign=-1 windValue=1 windSum=? 0->1 (max=1) done=0 tiny=0 opp=1
debugShowSort [1] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.238109917 tEnd=0.0764226429 sign=1 windValue=1 windSum=? 1->0 (max=1) done=0 tiny=0 opp=0
debugShowSort [2] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.281761651 tEnd=0 sign=1 windValue=1 windSum=? 1->0 (max=1) done=0 tiny=0 opp=1
findNextOp firstIndex=[3] sign=-1
activeOp op=union miFrom=1 miTo=1 suFrom=0 suTo=1 result=0
markDoneBinary id=3 (0,2 1,5 1,0 6,1) t=0.281761651 [1] (0.741329789,2.94366908) tEnd=0.633333333 newWindSum=1 newOppSum=1 oppSum=? windSum=? windValue=1
findNextOp chase.append id=3
activeOp op=union miFrom=1 miTo=0 suFrom=1 suTo=1 result=0
markDoneBinary id=1 (0,1 1,6 2,0 5,1) t=0.0764226429 [1] (0.230160609,1.96163988) tEnd=0.238109917 newWindSum=1 newOppSum=1 oppSum=? windSum=? windValue=1
findNextOp chase.append id=1
activeOp op=union miFrom=0 miTo=0 suFrom=1 suTo=0 result=1
markWinding id=3 (0,2 1,5 1,0 6,1) t=0 [0] (0,2) tEnd=0.281761651 newWindSum=1 newOppSum=0 oppSum=? windSum=? windValue=1
markWinding id=4 (6,1 0,2) t=0.961639898 [3] (0.230160609,1.96163988) tEnd=1 newWindSum=1 newOppSum=0 oppSum=? windSum=? windValue=1
findNextOp chase.append id=4
markDoneBinary id=1 (0,1 1,6 2,0 5,1) t=0.238109917 [2] (0.741329789,2.94366908) tEnd=0.691654855 newWindSum=1 newOppSum=0 oppSum=0 windSum=1 windValue=1
findNextOp from:[1] to:[3] start=1 end=0
bridgeOp current id=1 from=(2.73672128,1.54387975) to=(0.741329789,2.94366908)
path.lineTo(2.73672128,1.54387975);
path.cubicTo(1.84923673,2.27202392, 1.2463032,3.29839373, 0.741329789,2.94366908);
findNextOp simple
markDoneBinary id=3 (0,2 1,5 1,0 6,1) t=0 [0] (0,2) tEnd=0.281761651 newWindSum=1 newOppSum=0 oppSum=0 windSum=1 windValue=1
bridgeOp current id=3 from=(0.741329789,2.94366908) to=(0,2)
path.cubicTo(0.484133661,3.05545282, 0.281761646,2.84528494, 0,2);
findNextOp debugShowSort contourWinding=0 oppContourWinding=0 sign=-1
debugShowSort [2] {{6,1}, {0,2}} tStart=0.961639898 tEnd=1 sign=-1 windValue=1 windSum=1 0->1 (max=1) done=0 tiny=0 opp=0
debugShowSort [3] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.0764226429 tEnd=0.238109917 sign=-1 windValue=1 windSum=1 0->1 (max=1) done=1 tiny=0 opp=1
debugShowSort [0] {{6,1}, {0,2}} tStart=0.961639898 tEnd=0.629851852 sign=1 windValue=1 windSum=? 1->0 (max=1) done=0 tiny=0 opp=0
debugShowSort [1] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.0764226429 tEnd=0 sign=1 windValue=1 windSum=? 1->0 (max=1) done=0 tiny=0 opp=1
findNextOp firstIndex=[2] sign=-1
activeOp op=union miFrom=0 miTo=1 suFrom=1 suTo=1 result=0
activeOp op=union miFrom=1 miTo=1 suFrom=1 suTo=0 result=0
markDoneBinary id=4 (6,1 0,2) t=0.629851852 [2] (2.22088885,1.62985182) tEnd=0.961639898 newWindSum=1 newOppSum=1 oppSum=? windSum=? windValue=1
findNextOp chase.append id=4
activeOp op=union miFrom=1 miTo=0 suFrom=0 suTo=0 result=1
markWinding id=1 (0,1 1,6 2,0 5,1) t=0 [0] (0,1) tEnd=0.0764226429 newWindSum=1 newOppSum=0 oppSum=? windSum=? windValue=1
markWinding id=2 (5,1 0,1) t=0.283328113 [2] (3.58335948,1) tEnd=1 newWindSum=1 newOppSum=0 oppSum=? windSum=? windValue=1
findNextOp chase.append id=2
markDoneBinary id=4 (6,1 0,2) t=0.961639898 [3] (0.230160609,1.96163988) tEnd=1 newWindSum=1 newOppSum=0 oppSum=0 windSum=1 windValue=1
findNextOp from:[4] to:[1] start=1 end=0
bridgeOp current id=4 from=(0,2) to=(0.230160609,1.96163988)
findNextOp simple
markDoneBinary id=1 (0,1 1,6 2,0 5,1) t=0 [0] (0,1) tEnd=0.0764226429 newWindSum=1 newOppSum=0 oppSum=0 windSum=1 windValue=1
bridgeOp current id=1 from=(0.230160609,1.96163988) to=(0,1)
path.lineTo(0.230160609,1.96163988);
path.cubicTo(0.152845293,1.69998181, 0.0764226392,1.38211322, 0,1);
findNextOp debugShowSort contourWinding=0 oppContourWinding=0 sign=-1
debugShowSort [1] {{5,1}, {0,1}} tStart=0.283328113 tEnd=1 sign=-1 windValue=1 windSum=1 0->1 (max=1) done=0 tiny=0 opp=0
debugShowSort [2] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.803214143 tEnd=0.633333333 sign=1 windValue=1 windSum=? 0->-1 (max=-1) done=0 tiny=0 opp=1
debugShowSort [3] {{5,1}, {0,1}} tStart=0.283328113 tEnd=0.268518519 sign=1 windValue=1 windSum=? 1->0 (max=1) done=0 tiny=0 opp=0
debugShowSort [0] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.803214143 tEnd=0.83051493 sign=-1 windValue=1 windSum=? -1->0 (max=-1) done=0 tiny=0 opp=1
findNextOp firstIndex=[1] sign=-1
activeOp op=union miFrom=1 miTo=1 suFrom=0 suTo=1 result=0
markDoneBinary id=3 (0,2 1,5 1,0 6,1) t=0.633333333 [2] (2.22088885,1.62985182) tEnd=0.803214143 newWindSum=-1 newOppSum=1 oppSum=? windSum=? windValue=1
findNextOp chase.append id=3
activeOp op=union miFrom=1 miTo=0 suFrom=1 suTo=1 result=0
markDoneBinary id=2 (5,1 0,1) t=0.268518519 [1] (3.65740752,1) tEnd=0.283328113 newWindSum=1 newOppSum=-1 oppSum=? windSum=? windValue=1
findNextOp chase.append id=2
activeOp op=union miFrom=0 miTo=0 suFrom=1 suTo=0 result=1
markWinding id=3 (0,2 1,5 1,0 6,1) t=0.803214143 [3] (3.58335948,1) tEnd=0.83051493 newWindSum=-1 newOppSum=0 oppSum=? windSum=? windValue=1
findNextOp chase.append id=3
markDoneBinary id=2 (5,1 0,1) t=0.283328113 [2] (3.58335948,1) tEnd=1 newWindSum=1 newOppSum=0 oppSum=0 windSum=1 windValue=1
findNextOp from:[2] to:[3] start=3 end=4
bridgeOp current id=2 from=(0,1) to=(3.58335948,1)
findNextOp debugShowSort contourWinding=0 oppContourWinding=0 sign=1
debugShowSort [0] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.83051493 tEnd=0.803214143 sign=1 windValue=1 windSum=-1 0->-1 (max=-1) done=0 tiny=0 opp=0
debugShowSort [1] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.860977989 tEnd=0.833333333 sign=1 windValue=1 windSum=? 0->-1 (max=-1) done=0 tiny=0 opp=1
debugShowSort [2] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.860977989 tEnd=0.860978176 sign=-1 windValue=1 windSum=? -1->0 (max=-1) done=0 tiny=0 opp=1
debugShowSort [3] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.83051493 tEnd=0.830515061 sign=-1 windValue=1 windSum=? -1->0 (max=-1) done=0 tiny=0 opp=0
findNextOp firstIndex=[0] sign=1
activeOp op=union miFrom=0 miTo=1 suFrom=1 suTo=1 result=0
markDoneBinary id=1 (0,1 1,6 2,0 5,1) t=0.833333333 [4] (3.65740752,1) tEnd=0.860977989 newWindSum=-1 newOppSum=-1 oppSum=? windSum=? windValue=1
findNextOp chase.append id=1
activeOp op=union miFrom=1 miTo=0 suFrom=1 suTo=1 result=0
markDoneBinary id=1 (0,1 1,6 2,0 5,1) t=0.860977989 [5] (3.85939074,0.940439343) tEnd=0.860978176 newWindSum=-1 newOppSum=-1 oppSum=? windSum=? windValue=1
findNextOp chase.append id=1
activeOp op=union miFrom=0 miTo=0 suFrom=1 suTo=0 result=1
markWinding id=3 (0,2 1,5 1,0 6,1) t=0.83051493 [4] (3.85939074,0.940439343) tEnd=0.830515061 newWindSum=-1 newOppSum=0 oppSum=? windSum=? windValue=1
findNextOp chase.append id=3
markDoneBinary id=3 (0,2 1,5 1,0 6,1) t=0.803214143 [3] (3.58335948,1) tEnd=0.83051493 newWindSum=-1 newOppSum=0 oppSum=0 windSum=-1 windValue=1
findNextOp from:[3] to:[3] start=4 end=5
bridgeOp current id=3 from=(3.58335948,1) to=(3.85939074,0.940439343)
path.lineTo(3.58335948,1);
path.cubicTo(3.67248249,0.97763288, 3.76445246,0.957684338, 3.85939074,0.940439343);
findNextOp debugShowSort contourWinding=0 oppContourWinding=0 sign=1
debugShowSort [2] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.830515061 tEnd=0.83051493 sign=1 windValue=1 windSum=-1 0->-1 (max=-1) done=0 tiny=0 opp=0
debugShowSort [3] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.860978176 tEnd=0.860977989 sign=1 windValue=1 windSum=-1 0->-1 (max=-1) done=1 tiny=0 opp=1
debugShowSort [0] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.830515061 tEnd=0.867315861 sign=-1 windValue=1 windSum=? -1->0 (max=-1) done=0 tiny=0 opp=0
debugShowSort [1] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.860978176 tEnd=0.912837717 sign=-1 windValue=1 windSum=? -1->0 (max=-1) done=0 tiny=0 opp=1
findNextOp firstIndex=[2] sign=1
activeOp op=union miFrom=0 miTo=1 suFrom=1 suTo=1 result=0
activeOp op=union miFrom=1 miTo=1 suFrom=1 suTo=0 result=0
markDoneBinary id=3 (0,2 1,5 1,0 6,1) t=0.830515061 [5] (3.85939217,0.940439045) tEnd=0.867315861 newWindSum=-1 newOppSum=-1 oppSum=? windSum=? windValue=1
findNextOp chase.append id=3
activeOp op=union miFrom=1 miTo=0 suFrom=0 suTo=0 result=1
markWinding id=1 (0,1 1,6 2,0 5,1) t=0.860978176 [6] (3.85939217,0.940439045) tEnd=0.912837717 newWindSum=-1 newOppSum=0 oppSum=? windSum=? windValue=1
findNextOp chase.append id=1
markDoneBinary id=3 (0,2 1,5 1,0 6,1) t=0.83051493 [4] (3.85939074,0.940439343) tEnd=0.830515061 newWindSum=-1 newOppSum=0 oppSum=0 windSum=-1 windValue=1
findNextOp from:[3] to:[1] start=6 end=7
bridgeOp current id=3 from=(3.85939074,0.940439343) to=(3.85939217,0.940439045)
path.cubicTo(3.85939145,0.940439224, 3.85939169,0.940439165, 3.85939217,0.940439045);
findNextOp debugShowSort contourWinding=0 oppContourWinding=0 sign=1
debugShowSort [0] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.912837717 tEnd=0.860978176 sign=1 windValue=1 windSum=-1 0->-1 (max=-1) done=0 tiny=0 opp=0
debugShowSort [1] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.867315861 tEnd=0.830515061 sign=1 windValue=1 windSum=-1 0->-1 (max=-1) done=1 tiny=0 opp=1
debugShowSort [2] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.912837717 tEnd=0.912837923 sign=-1 windValue=1 windSum=? -1->0 (max=-1) done=0 tiny=0 opp=0
debugShowSort [3] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.867315861 tEnd=0.867316009 sign=-1 windValue=1 windSum=? -1->0 (max=-1) done=0 tiny=0 opp=1
findNextOp firstIndex=[0] sign=1
activeOp op=union miFrom=1 miTo=1 suFrom=0 suTo=1 result=0
activeOp op=union miFrom=1 miTo=0 suFrom=1 suTo=1 result=0
markDoneBinary id=1 (0,1 1,6 2,0 5,1) t=0.912837717 [7] (4.25979853,0.886136234) tEnd=0.912837923 newWindSum=-1 newOppSum=-1 oppSum=? windSum=? windValue=1
findNextOp chase.append id=1
activeOp op=union miFrom=0 miTo=0 suFrom=1 suTo=0 result=1
markWinding id=3 (0,2 1,5 1,0 6,1) t=0.867315861 [6] (4.25979853,0.886136234) tEnd=0.867316009 newWindSum=-1 newOppSum=0 oppSum=? windSum=? windValue=1
findNextOp chase.append id=3
markDoneBinary id=1 (0,1 1,6 2,0 5,1) t=0.860978176 [6] (3.85939217,0.940439045) tEnd=0.912837717 newWindSum=-1 newOppSum=0 oppSum=0 windSum=-1 windValue=1
findNextOp from:[1] to:[3] start=6 end=7
bridgeOp current id=1 from=(3.85939217,0.940439045) to=(4.25979853,0.886136234)
path.cubicTo(3.98813701,0.909405351, 4.12151289,0.890467525, 4.25980043,0.886136055);
path.close();
debugShowActiveSpans id=3 (0,2 1,5 1,0 6,1) t=0.867315861 (4.25979853,0.886136234) tEnd=0.867316009 other=1 otherT=0.912837717 otherIndex=7 windSum=-1 windValue=1 oppValue=0
debugShowActiveSpans id=1 (0,1 1,6 2,0 5,1) t=0.912837923 (4.25980043,0.886136055) tEnd=1 other=3 otherT=0.867316009 otherIndex=7 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=2 (5,1 0,1) t=0 (5,1) tEnd=0.268518519 other=1 otherT=1 otherIndex=9 windSum=? windValue=1 oppValue=0
activeOp op=union miFrom=0 miTo=0 suFrom=0 suTo=1 result=1
findNextOp debugShowSort contourWinding=-1 oppContourWinding=0 sign=-1
debugShowSort [3] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.867315861 tEnd=0.867316009 sign=-1 windValue=1 windSum=-1 -1->0 (max=-1) done=0 tiny=0 opp=0
debugShowSort [0] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.912837717 tEnd=0.860978176 sign=1 windValue=1 windSum=-1 0->-1 (max=-1) done=1 tiny=0 opp=1
debugShowSort [1] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.867315861 tEnd=0.830515061 sign=1 windValue=1 windSum=-1 0->-1 (max=-1) done=1 tiny=0 opp=0
debugShowSort [2] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.912837717 tEnd=0.912837923 sign=-1 windValue=1 windSum=-1 -1->0 (max=-1) done=1 tiny=0 opp=1
findNextOp firstIndex=[3] sign=-1
activeOp op=union miFrom=0 miTo=1 suFrom=0 suTo=0 result=1
activeOp op=union miFrom=1 miTo=1 suFrom=0 suTo=1 result=0
activeOp op=union miFrom=1 miTo=0 suFrom=1 suTo=1 result=0
markDoneBinary id=3 (0,2 1,5 1,0 6,1) t=0.867315861 [6] (4.25979853,0.886136234) tEnd=0.867316009 newWindSum=-1 newOppSum=0 oppSum=0 windSum=-1 windValue=1
findNextOp from:[3] to:[1] start=7 end=6
bridgeOp current id=3 from=(4.25980043,0.886136055) to=(4.25979853,0.886136234)
path.moveTo(4.25980043,0.886136055);
path.cubicTo(4.25979948,0.886136115, 4.25979948,0.886136174, 4.25979853,0.886136234);
findNextOp debugShowSort contourWinding=-1 oppContourWinding=0 sign=-1
debugShowSort [1] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.860978176 tEnd=0.912837717 sign=-1 windValue=1 windSum=-1 -1->0 (max=-1) done=1 tiny=0 opp=0
debugShowSort [2] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.830515061 tEnd=0.83051493 sign=1 windValue=1 windSum=-1 0->-1 (max=-1) done=1 tiny=0 opp=1
debugShowSort [3] {{0,1}, {1,6}, {2,0}, {5,1}} tStart=0.860978176 tEnd=0.860977989 sign=1 windValue=1 windSum=-1 0->-1 (max=-1) done=1 tiny=0 opp=0
debugShowSort [0] {{0,2}, {1,5}, {1,0}, {6,1}} tStart=0.830515061 tEnd=0.867315861 sign=-1 windValue=1 windSum=-1 -1->0 (max=-1) done=1 tiny=0 opp=1
findNextOp firstIndex=[1] sign=-1
activeOp op=union miFrom=0 miTo=0 suFrom=0 suTo=1 result=1
activeOp op=union miFrom=0 miTo=1 suFrom=1 suTo=1 result=0
activeOp op=union miFrom=1 miTo=1 suFrom=1 suTo=0 result=0
findNextOp from:[1] to:[3] start=5 end=4
bridgeOp current id=1 from=(4.25979853,0.886136234) to=(3.85939217,0.940439045)
path.cubicTo(4.12151289,0.890467525, 3.98813701,0.909405351, 3.85939217,0.940439045);
debugShowActiveSpans id=1 (0,1 1,6 2,0 5,1) t=0.912837923 (4.25980043,0.886136055) tEnd=1 other=3 otherT=0.867316009 otherIndex=7 windSum=? windValue=1 oppValue=0
debugShowActiveSpans id=2 (5,1 0,1) t=0 (5,1) tEnd=0.268518519 other=1 otherT=1 otherIndex=9 windSum=? windValue=1 oppValue=0
</div>

<div id="cubicOp35da">
{{x = 0.44618727783085621, y = 2.2840286415243063}, {x = 0.51170845243761109, y = 2.4044088819954914}, {x = 0.57783675570457882, y = 2.4985733182515446}, {x = 0.64483584772311509, y = 2.5694222112973661}}
{{x = 0.64244110111854291, y = 2.5673840215265367}, {x = 0.63479413812245555, y = 2.5620057200094775}, {x = 0.64115438240274059, y = 2.533597555954064}, {x = 0.6620248993310307, y = 2.4876932484482714}}
</div>

</div>

<script type="text/javascript">

var testDivs = [
    cubicOp36u,
    cubicOp35da,
];

var decimal_places = 3; // make this 3 to show more precision

var tests = [];
var testLines = [];
var testTitles = [];
var testIndex = 0;
var ctx;

var xmin, xmax;
var ymin, ymax;
var scale;
var mouseX, mouseY;
var srcLeft, srcTop;
var screenWidth, screenHeight;
var drawnPts, drawnLines, drawnQuads, drawnCubics;
var curveT = 0;

var pt_labels = true;
var control_lines = false;
var curve_t = false;
var debug_xy = false;
var info_mode = false;
var step_limit = 0;
var draw_active = false;
var draw_add = false;
var draw_intersection = false;
var draw_intersectT = false;
var draw_legend = false;
var draw_log = false;
var draw_mark = false;
var draw_sort = false;
var draw_path = true;
var draw_computed = 0;

var SPAN_ID = 0;
var SPAN_X1 = SPAN_ID + 1;
var SPAN_Y1 = SPAN_X1 + 1;
var SPAN_X2 = SPAN_Y1 + 1;
var SPAN_Y2 = SPAN_X2 + 1;
var SPAN_L_T = SPAN_Y2 + 1;
var SPAN_L_TX = SPAN_L_T + 1;
var SPAN_L_TY = SPAN_L_TX + 1;
var SPAN_L_TEND = SPAN_L_TY + 1;
var SPAN_L_OTHER = SPAN_L_TEND + 1;
var SPAN_L_OTHERT = SPAN_L_OTHER + 1;
var SPAN_L_OTHERI = SPAN_L_OTHERT + 1;
var SPAN_L_SUM = SPAN_L_OTHERI + 1;
var SPAN_L_VAL = SPAN_L_SUM + 1;
var SPAN_L_OPP = SPAN_L_VAL + 1;

var SPAN_X3 = SPAN_Y2 + 1;
var SPAN_Y3 = SPAN_X3 + 1;
var SPAN_Q_T = SPAN_Y3 + 1;
var SPAN_Q_TX = SPAN_Q_T + 1;
var SPAN_Q_TY = SPAN_Q_TX + 1;
var SPAN_Q_TEND = SPAN_Q_TY + 1;
var SPAN_Q_OTHER = SPAN_Q_TEND + 1;
var SPAN_Q_OTHERT = SPAN_Q_OTHER + 1;
var SPAN_Q_OTHERI = SPAN_Q_OTHERT + 1;
var SPAN_Q_SUM = SPAN_Q_OTHERI + 1;
var SPAN_Q_VAL = SPAN_Q_SUM + 1;
var SPAN_Q_OPP = SPAN_Q_VAL + 1;

var SPAN_X4 = SPAN_Y3 + 1;
var SPAN_Y4 = SPAN_X4 + 1;
var SPAN_C_T = SPAN_Y4 + 1;
var SPAN_C_TX = SPAN_C_T + 1;
var SPAN_C_TY = SPAN_C_TX + 1;
var SPAN_C_TEND = SPAN_C_TY + 1;
var SPAN_C_OTHER = SPAN_C_TEND + 1;
var SPAN_C_OTHERT = SPAN_C_OTHER + 1;
var SPAN_C_OTHERI = SPAN_C_OTHERT + 1;
var SPAN_C_SUM = SPAN_C_OTHERI + 1;
var SPAN_C_VAL = SPAN_C_SUM + 1;
var SPAN_C_OPP = SPAN_C_VAL + 1;

var ACTIVE_LINE_SPAN =        1;
var ACTIVE_QUAD_SPAN =        ACTIVE_LINE_SPAN + 1;
var ACTIVE_CUBIC_SPAN =       ACTIVE_QUAD_SPAN + 1;

var ADD_MOVETO =              ACTIVE_CUBIC_SPAN + 1;
var ADD_LINETO =              ADD_MOVETO + 1;
var ADD_QUADTO =              ADD_LINETO + 1;
var ADD_CUBICTO =             ADD_QUADTO + 1;
var ADD_CLOSE =               ADD_CUBICTO + 1;

var PATH_LINE =               ADD_CLOSE + 1;
var PATH_QUAD =               PATH_LINE + 1;
var PATH_CUBIC =              PATH_QUAD + 1;

var INTERSECT_LINE =          PATH_CUBIC + 1;
var INTERSECT_LINE_2 =        INTERSECT_LINE + 1;
var INTERSECT_LINE_NO =       INTERSECT_LINE_2 + 1;
var INTERSECT_QUAD_LINE =     INTERSECT_LINE_NO + 1;
var INTERSECT_QUAD_LINE_2 =   INTERSECT_QUAD_LINE + 1;
var INTERSECT_QUAD_LINE_NO =  INTERSECT_QUAD_LINE_2 + 1;
var INTERSECT_QUAD =          INTERSECT_QUAD_LINE_NO + 1;
var INTERSECT_QUAD_2 =        INTERSECT_QUAD + 1;
var INTERSECT_QUAD_NO =       INTERSECT_QUAD_2 + 1;
var INTERSECT_SELF_CUBIC =    INTERSECT_QUAD_NO + 1;
var INTERSECT_SELF_CUBIC_NO = INTERSECT_SELF_CUBIC + 1;
var INTERSECT_CUBIC_LINE =    INTERSECT_SELF_CUBIC_NO + 1;
var INTERSECT_CUBIC_LINE_2 =  INTERSECT_CUBIC_LINE + 1;
var INTERSECT_CUBIC_LINE_3 =  INTERSECT_CUBIC_LINE_2 + 1;
var INTERSECT_CUBIC_LINE_NO = INTERSECT_CUBIC_LINE_3 + 1;
// FIXME: add cubic/quad
var INTERSECT_CUBIC =         INTERSECT_CUBIC_LINE_NO + 1;
var INTERSECT_CUBIC_2 =       INTERSECT_CUBIC + 1;
var INTERSECT_CUBIC_3 =       INTERSECT_CUBIC_2 + 1;
var INTERSECT_CUBIC_4 =       INTERSECT_CUBIC_3 + 1;
// FIXME: add cubic 5- 9
var INTERSECT_CUBIC_NO =      INTERSECT_CUBIC_4 + 1;

var SORT_LINE =               INTERSECT_CUBIC_NO + 1;
var SORT_QUAD =               SORT_LINE + 1;
var SORT_CUBIC =              SORT_QUAD + 1;

var OP_DIFFERENCE =           SORT_CUBIC + 1;
var OP_INTERSECT =            OP_DIFFERENCE + 1;
var OP_UNION =                OP_INTERSECT + 1;
var OP_XOR =                  OP_UNION + 1;

var MARK_LINE =               OP_XOR + 1;
var MARK_QUAD =               MARK_LINE + 1;
var MARK_CUBIC =              MARK_QUAD + 1;
var MARK_DONE_LINE =          MARK_CUBIC + 1;
var MARK_DONE_QUAD =          MARK_DONE_LINE + 1;
var MARK_DONE_CUBIC =         MARK_DONE_QUAD + 1;

var COMPUTED_ORIGINAL =       MARK_DONE_CUBIC + 1;
var COMPUTED_QUAD =           COMPUTED_ORIGINAL + 1;

var REC_TYPE_UNKNOWN = -1;
var REC_TYPE_PATH = 0;
var REC_TYPE_SECT = 1;
var REC_TYPE_ACTIVE = 2;
var REC_TYPE_ADD = 3;
var REC_TYPE_SORT = 4;
var REC_TYPE_OP = 5;
var REC_TYPE_MARK = 6;
var REC_TYPE_COMPUTED = 7;
var REC_TYPE_LAST = REC_TYPE_COMPUTED;

function strs_to_nums(strs) {
    var result = [];
    for (var idx = 1; idx < strs.length; ++idx) {
        var str = strs[idx];
        var num = parseFloat(str);
        if (isNaN(num)) {
            result.push(str);
        } else {
            result.push(num);
        }
    }
    return result;
}

function construct_regexp(pattern) {
    var escape = pattern.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
    escape = escape.replace(/PT_VAL/g, "(\\d+\\.?\\d*),(\\d+\\.?\\d*)");
    escape = escape.replace(/T_VAL/g, "(\\d+\\.?\\d*e?-?\\d*)");
    escape = escape.replace(/IDX/g, "(\\d+)");
    escape = escape.replace(/OPT/g, "(\\?|-?\\d+)");
    return new RegExp(escape, 'i');
}

function parse_debugShowActiveSpans(test, title) {
    var re_cubic = construct_regexp(" id=IDX (PT_VAL PT_VAL PT_VAL PT_VAL) t=T_VAL (PT_VAL) tEnd=T_VAL other=IDX otherT=T_VAL otherIndex=IDX windSum=OPT windValue=IDX oppValue=IDX");
    var re_quad = construct_regexp(" id=IDX (PT_VAL PT_VAL PT_VAL) t=T_VAL (PT_VAL) tEnd=T_VAL other=IDX otherT=T_VAL otherIndex=IDX windSum=OPT windValue=IDX oppValue=IDX");
    var re_line = construct_regexp(" id=IDX (PT_VAL PT_VAL) t=T_VAL (PT_VAL) tEnd=T_VAL other=IDX otherT=T_VAL otherIndex=IDX windSum=OPT windValue=IDX oppValue=IDX");
    
    var strs = test.split("debugShowActiveSpans");
    if (strs.length == 1)
        return;
    var spans = [];
    for (var s = 0; s < strs.length; ++s) {
        var str = strs[s];
        if (str == "\n") {
            continue;
        }
        if (re_line.test(str)) {
            var lineStrs = re_line.exec(str);
            var line = strs_to_nums(lineStrs);
            spans.push(ACTIVE_LINE_SPAN);
            spans.push(line);
        } else if (re_quad.test(str)) {
            var quadStrs = re_quad.exec(str);
            var quad = strs_to_nums(quadStrs);
            spans.push(ACTIVE_QUAD_SPAN);
            spans.push(quad);
        } else if (re_cubic.test(str)) {
            var cubicStrs = re_cubic.exec(str);
            var cubic = strs_to_nums(cubicStrs);
            spans.push(ACTIVE_CUBIC_SPAN);
            spans.push(cubic);
        }
    }
    if (spans.length >= 1) {
        tests.push(spans);
        testTitles.push(title);
    }
}

function filter_str_by(id, str, regex, array) {
    if (regex.test(str)) {
        var strs = regex.exec(str);
        var result = strs_to_nums(strs);
        array.push(id);
        array.push(result);
        return true;
    }
    return false;
}

// FIXME: add cubic support
function parse_intersections(test, title) {
    var re_quad_line = construct_regexp(" wtTs[0]=T_VAL (PT_VAL PT_VAL PT_VAL) (PT_VAL) wnTs[0]=T_VAL (PT_VAL PT_VAL) (PT_VAL)");
    var re_quad_line_2 = construct_regexp(" wtTs[0]=T_VAL (PT_VAL PT_VAL PT_VAL) (PT_VAL) wtTs[1]=T_VAL (PT_VAL) wnTs[0]=T_VAL (PT_VAL PT_VAL) (PT_VAL) wnTs[1]=T_VAL (PT_VAL)");
    var re_quad_line_no_intersect = construct_regexp(" no intersect (PT_VAL PT_VAL PT_VAL) (PT_VAL PT_VAL)");
    var re_quad = construct_regexp(" wtTs[0]=T_VAL (PT_VAL PT_VAL PT_VAL) (PT_VAL) wnTs[0]=T_VAL (PT_VAL PT_VAL PT_VAL) (PT_VAL)");
    var re_quad_2 = construct_regexp(" wtTs[0]=T_VAL (PT_VAL PT_VAL PT_VAL) (PT_VAL) wtTs[1]=T_VAL wnTs[0]=T_VAL (PT_VAL PT_VAL PT_VAL) (PT_VAL) wnTs[1]=T_VAL");
    var re_quad_no_intersect = construct_regexp(" no intersect (PT_VAL PT_VAL PT_VAL) (PT_VAL PT_VAL PT_VAL)");
    
    var strs = test.split(/debugShow[A-Za-z]+Intersection/);
    if (strs.length == 1)
        return;
    var spans = [];
    for (var s = 0; s < strs.length; ++s) {
        var str = strs[s];
        if (str == "\n") {
            continue;
        }
        filter_str_by(INTERSECT_QUAD_LINE, str, re_quad_line, spans);
        filter_str_by(INTERSECT_QUAD_LINE_2, str, re_quad_line_2, spans);
        filter_str_by(INTERSECT_QUAD_LINE_NO, str, re_quad_line_no_intersect, spans);
        filter_str_by(INTERSECT_QUAD, str, re_quad, spans);
        filter_str_by(INTERSECT_QUAD_2, str, re_quad_2, spans);
        filter_str_by(INTERSECT_QUAD_NO, str, re_quad_no_intersect, spans);
    }
    if (spans.length >= 1) {
        tests.push(spans);
        testTitles.push(title);
    }
}

function construct_regexp2(pattern) {
    var escape = pattern.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
    escape = escape.replace(/CUBIC_VAL/g, "\\(P_VAL P_VAL P_VAL P_VAL\\)");
    escape = escape.replace(/QUAD_VAL/g, "\\(P_VAL P_VAL P_VAL\\)");
    escape = escape.replace(/LINE_VAL/g, "\\(P_VAL P_VAL\\)");
    escape = escape.replace(/PT_VAL/g, "\\(P_VAL\\)");
    escape = escape.replace(/P_VAL/g, "(\\d+\\.?\\d*),(\\d+\\.?\\d*)");
    escape = escape.replace(/T_VAL/g, "(\\d+\\.?\\d*e?-?\\d*)");
    escape = escape.replace(/IDX/g, "(\\d+)");
    escape = escape.replace(/NUM/g, "(-?\\d+)");
    escape = escape.replace(/OPT/g, "(\\?|-?\\d+)");
    return new RegExp(escape, 'i');
}

function construct_regexp2c(pattern) {
    var escape = pattern.replace(/[-/\\^$*+?.()|[\]{}]/g, '\\$&');
    escape = escape.replace(/CUBIC_VAL/g, "\\{\\{P_VAL\\}, \\{P_VAL\\}, \\{P_VAL\\}, \\{P_VAL\\}\\}");
    escape = escape.replace(/QUAD_VAL/g, "\\{\\{P_VAL\\}, \\{P_VAL\\}, \\{P_VAL\\}\\}");
    escape = escape.replace(/LINE_VAL/g, "\\{\\{P_VAL\\}, \\{P_VAL\\}\\}");
    escape = escape.replace(/PT_VAL/g, "\\{\\{P_VAL\\}\\}");
    escape = escape.replace(/P_VAL/g, "(?:x = )?(\\d+\\.?\\d*),(?: y = )?(\\d+\\.?\\d*)");
    escape = escape.replace(/T_VAL/g, "(\\d+\\.?\\d*e?-?\\d*)");
    escape = escape.replace(/IDX/g, "(\\d+)");
    escape = escape.replace(/NUM/g, "(-?\\d+)");
    escape = escape.replace(/OPT/g, "(\\?|-?\\d+)");
    return new RegExp(escape, 'i');
}

function match_regexp(str, lineNo, array, id, pattern) {
    var regex = construct_regexp2(pattern);
    if (filter_str_by(id, str, regex, array)) {
        return true;
    }
    regex = construct_regexp2c(pattern);
    return filter_str_by(id, str, regex, array);
}

function parse_all(test, title) {
    var lines = test.match(/[^\r\n]+/g);
    var records = []; // a rec can be the original paths, a set of intersections, a set of active spans, a sort, or a path add
    var record = [];
    var recType = REC_TYPE_UNKNOWN;
    var lastLineNo;
    for (var lineNo = 0; lineNo < lines.length; ++lineNo) {
        var line = lines[lineNo];
        if (line.length == 0) {
            continue;
        }
        var type = line.lastIndexOf("debugShowSort", 0) === 0 ? REC_TYPE_SORT
                : line.lastIndexOf("debugShowActiveSpans", 0) === 0 ? REC_TYPE_ACTIVE 
                : line.lastIndexOf("debugShow", 0) === 0 ? REC_TYPE_SECT 
                : line.lastIndexOf("path.", 0) === 0 ? REC_TYPE_ADD
                : line.lastIndexOf("mark", 0) === 0 ? REC_TYPE_MARK
                : line.lastIndexOf("{{", 0) === 0 ? REC_TYPE_PATH
                : line.lastIndexOf("  {{", 0) === 0 ? REC_TYPE_COMPUTED
                : line.lastIndexOf("op", 0) === 0 ? REC_TYPE_OP
                : line.lastIndexOf("computed", 0) === 0 ? REC_TYPE_COMPUTED
                : REC_TYPE_UNKNOWN;
        if (recType != type || recType == REC_TYPE_ADD) {
            if (recType != REC_TYPE_UNKNOWN) {
                records.push(recType);
                records.push(lastLineNo);
                records.push(record);
            }
            record = [];
            recType = type;
            lastLineNo = lineNo;
        }
        var found = false;
        switch (recType) {
            case REC_TYPE_ACTIVE:
                found = match_regexp(line, lineNo, record, ACTIVE_LINE_SPAN, "debugShowActiveSpans" +
" id=IDX LINE_VAL t=T_VAL PT_VAL tEnd=T_VAL other=IDX otherT=T_VAL otherIndex=IDX windSum=OPT windValue=IDX oppValue=IDX"
                ) || match_regexp(line, lineNo, record, ACTIVE_QUAD_SPAN, "debugShowActiveSpans" +
" id=IDX QUAD_VAL t=T_VAL PT_VAL tEnd=T_VAL other=IDX otherT=T_VAL otherIndex=IDX windSum=OPT windValue=IDX oppValue=IDX"
                ) || match_regexp(line, lineNo, record, ACTIVE_CUBIC_SPAN, "debugShowActiveSpans" +
" id=IDX CUBIC_VAL t=T_VAL PT_VAL tEnd=T_VAL other=IDX otherT=T_VAL otherIndex=IDX windSum=OPT windValue=IDX oppValue=IDX"
                );
                break;
            case REC_TYPE_ADD:
                found = match_regexp(line, lineNo, record, ADD_MOVETO, "path.moveTo(P_VAL);"
                ) || match_regexp(line, lineNo, record, ADD_LINETO, "path.lineTo(P_VAL);"
                ) || match_regexp(line, lineNo, record, ADD_QUADTO, "path.quadTo(P_VAL, P_VAL);"
                ) || match_regexp(line, lineNo, record, ADD_CUBICTO, "path.cubicTo(P_VAL, P_VAL, P_VAL);"
                ) || match_regexp(line, lineNo, record, ADD_CLOSE, "path.close();"
                );
                break;
            case REC_TYPE_COMPUTED:
                found = line == "computed quadratics given"
                  || match_regexp(line, lineNo, record, PATH_QUAD, "  QUAD_VAL,"
                ) || match_regexp(line, lineNo, record, PATH_CUBIC, "  CUBIC_VAL,"
                );
                break;
            case REC_TYPE_PATH:
                found = match_regexp(line, lineNo, record, PATH_LINE, "LINE_VAL"
                ) || match_regexp(line, lineNo, record, PATH_QUAD, "QUAD_VAL"
                ) || match_regexp(line, lineNo, record, PATH_CUBIC, "CUBIC_VAL"
                );
                break;
            case REC_TYPE_SECT:
                found = match_regexp(line, lineNo, record, INTERSECT_LINE, "debugShowLineIntersection" +
" wtTs[0]=T_VAL LINE_VAL PT_VAL wnTs[0]=T_VAL LINE_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_LINE_2, "debugShowLineIntersection" +
" wtTs[0]=T_VAL LINE_VAL PT_VAL wtTs[1]=T_VAL PT_VAL wnTs[0]=T_VAL LINE_VAL wnTs[1]=T_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_LINE_NO, "debugShowLineIntersection" +
" no intersect LINE_VAL LINE_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_QUAD_LINE, "debugShowQuadLineIntersection" +
" wtTs[0]=T_VAL QUAD_VAL PT_VAL wnTs[0]=T_VAL LINE_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_QUAD_LINE_2, "debugShowQuadLineIntersection" +
" wtTs[0]=T_VAL QUAD_VAL PT_VAL wtTs[1]=T_VAL PT_VAL wnTs[0]=T_VAL LINE_VAL wnTs[1]=T_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_QUAD_LINE_NO, "debugShowQuadLineIntersection" +
" no intersect QUAD_VAL LINE_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_QUAD, "debugShowQuadIntersection" +
" wtTs[0]=T_VAL QUAD_VAL PT_VAL wnTs[0]=T_VAL QUAD_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_QUAD_2, "debugShowQuadIntersection" +
" wtTs[0]=T_VAL QUAD_VAL PT_VAL wtTs[1]=T_VAL wnTs[0]=T_VAL QUAD_VAL wnTs[1]=T_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_QUAD_NO, "debugShowQuadIntersection" +
" no intersect QUAD_VAL QUAD_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_CUBIC_LINE, "debugShowCubicLineIntersection" +
" wtTs[0]=T_VAL CUBIC_VAL PT_VAL wnTs[0]=T_VAL LINE_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_CUBIC_LINE_2, "debugShowCubicLineIntersection" +
" wtTs[0]=T_VAL CUBIC_VAL PT_VAL wtTs[1]=T_VAL PT_VAL wnTs[0]=T_VAL LINE_VAL wnTs[1]=T_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_CUBIC_LINE_3, "debugShowCubicLineIntersection" +
" wtTs[0]=T_VAL CUBIC_VAL PT_VAL wtTs[1]=T_VAL PT_VAL wtTs[2]=T_VAL PT_VAL wnTs[0]=T_VAL LINE_VAL wnTs[1]=T_VAL wnTs[2]=T_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_CUBIC_LINE_NO, "debugShowCubicLineIntersection" +
" no intersect CUBIC_VAL LINE_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_CUBIC, "debugShowCubicIntersection" +
" wtTs[0]=T_VAL CUBIC_VAL PT_VAL wnTs[0]=T_VAL CUBIC_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_CUBIC_2, "debugShowCubicIntersection" +
" wtTs[0]=T_VAL CUBIC_VAL PT_VAL wtTs[1]=T_VAL PT_VAL wnTs[0]=T_VAL CUBIC_VAL wnTs[1]=T_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_CUBIC_3, "debugShowCubicIntersection" +
" wtTs[0]=T_VAL CUBIC_VAL PT_VAL wtTs[1]=T_VAL PT_VAL wtTs[2]=T_VAL PT_VAL wnTs[0]=T_VAL CUBIC_VAL wnTs[1]=T_VAL wnTs[2]=T_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_CUBIC_4, "debugShowCubicIntersection" +
" wtTs[0]=T_VAL CUBIC_VAL PT_VAL wtTs[1]=T_VAL PT_VAL wtTs[2]=T_VAL PT_VAL wtTs[3]=T_VAL PT_VAL wnTs[0]=T_VAL CUBIC_VAL wnTs[1]=T_VAL wnTs[2]=T_VAL wnTs[3]=T_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_CUBIC_NO, "debugShowCubicIntersection" +
" no intersect CUBIC_VAL CUBIC_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_SELF_CUBIC, "debugShowCubicIntersection" +
" wtTs[0]=T_VAL CUBIC_VAL PT_VAL wtTs[1]=T_VAL"
                ) || match_regexp(line, lineNo, record, INTERSECT_SELF_CUBIC_NO, "debugShowCubicIntersection" +
" no self intersect CUBIC_VAL"
                );
                break;
            case REC_TYPE_SORT:
                found =  match_regexp(line, lineNo, record, SORT_LINE, "debugShowSort" +
" [IDX] LINE_VAL tStart=T_VAL tEnd=T_VAL sign=NUM windValue=IDX windSum=OPT NUM->NUM (max=NUM) done=IDX tiny=IDX opp=IDX"
                ) || match_regexp(line, lineNo, record, SORT_QUAD, "debugShowSort" +
" [IDX] QUAD_VAL tStart=T_VAL tEnd=T_VAL sign=NUM windValue=IDX windSum=OPT NUM->NUM (max=NUM) done=IDX tiny=IDX opp=IDX"
                ) || match_regexp(line, lineNo, record, SORT_CUBIC, "debugShowSort" +
" [IDX] CUBIC_VAL tStart=T_VAL tEnd=T_VAL sign=NUM windValue=IDX windSum=OPT NUM->NUM (max=NUM) done=IDX tiny=IDX opp=IDX"
                ) || match_regexp(line, lineNo, record, SORT_LINE_COMPACT, "debugShowSort" +
" [IDX] id=IDX line start=IDX PT_VAL end=IDX PT_VAL sign=NUM windValue=IDX windSum=OPT NUM->NUM (max=NUM) done=IDX tiny=IDX opp=IDX"
                ) || match_regexp(line, lineNo, record, SORT_QUAD_COMPACT, "debugShowSort" +
" [IDX] id=IDX quad start=IDX PT_VAL end=IDX PT_VAL sign=NUM windValue=IDX windSum=OPT NUM->NUM (max=NUM) done=IDX tiny=IDX opp=IDX"
                ) || match_regexp(line, lineNo, record, SORT_CUBIC_COMPACT, "debugShowSort" +
" [IDX] id=IDX cubic start=IDX PT_VAL end=IDX PT_VAL sign=NUM windValue=IDX windSum=OPT NUM->NUM (max=NUM) done=IDX tiny=IDX opp=IDX"
                );
                break;
            case REC_TYPE_MARK:
                found =  match_regexp(line, lineNo, record, MARK_LINE, "markWinding" +
" id=IDX LINE_VAL t=T_VAL [IDX] PT_VAL tEnd=T_VAL newWindSum=NUM newOppSum=NUM oppSum=OPT windSum=OPT windValue=IDX"
                ) || match_regexp(line, lineNo, record, MARK_QUAD, "markWinding" +
" id=IDX QUAD_VAL t=T_VAL [IDX] PT_VAL tEnd=T_VAL newWindSum=NUM newOppSum=NUM oppSum=OPT windSum=OPT windValue=IDX"
                ) || match_regexp(line, lineNo, record, MARK_CUBIC, "markWinding" +
" id=IDX CUBIC_VAL t=T_VAL [IDX] PT_VAL tEnd=T_VAL newWindSum=NUM newOppSum=NUM oppSum=OPT windSum=OPT windValue=IDX"
                ) || match_regexp(line, lineNo, record, MARK_DONE_LINE, "markDoneBinary" +
" id=IDX LINE_VAL t=T_VAL [IDX] PT_VAL tEnd=T_VAL newWindSum=NUM newOppSum=NUM oppSum=OPT windSum=OPT windValue=IDX"
                ) || match_regexp(line, lineNo, record, MARK_DONE_QUAD, "markDoneBinary" +
" id=IDX QUAD_VAL t=T_VAL [IDX] PT_VAL tEnd=T_VAL newWindSum=NUM newOppSum=NUM oppSum=OPT windSum=OPT windValue=IDX"
                ) || match_regexp(line, lineNo, record, MARK_DONE_CUBIC, "markDoneBinary" +
" id=IDX CUBIC_VAL t=T_VAL [IDX] PT_VAL tEnd=T_VAL newWindSum=NUM newOppSum=NUM oppSum=OPT windSum=OPT windValue=IDX"
                );
                break;
            case REC_TYPE_OP:
                found = match_regexp(line, lineNo, record, OP_DIFFERENCE, "op difference"
                ) || match_regexp(line, lineNo, record, OP_INTERSECT, "op intersect"
                ) || match_regexp(line, lineNo, record, OP_UNION, "op union"
                ) || match_regexp(line, lineNo, record, OP_XOR, "op xor"
                );
                break;
            case REC_TYPE_UNKNOWN:
                found = true;
                break;
        }
        if (!found) {
            console.log(line + " [" + lineNo + "] of type " + type + " not found");
        }
    }
    if (recType != REC_TYPE_UNKNOWN) {
        records.push(recType);
        records.push(lastLineNo);
        records.push(record);
    }
    if (records.length >= 1) {
        tests.push(records);
        testLines.push(lines);
        testTitles.push(title);
    }
}

function init(test) {
    var canvas = document.getElementById('canvas');
    if (!canvas.getContext) return;
    screenWidth = canvas.width = window.innerWidth - 20;
    screenHeight = canvas.height = window.innerHeight - 20;
    ctx = canvas.getContext('2d');
    xmin = Infinity;
    xmax = -Infinity;
    ymin = Infinity;
    ymax = -Infinity;
    for (var testIndex = 0; testIndex < test.length; testIndex += 3) {
        var recType = test[testIndex];
        if (!typeof recType == 'number' || recType < REC_TYPE_UNKNOWN || recType > REC_TYPE_LAST) {
            console.log("unknown rec type: " + recType);
            throw "stop execution";
        }
        var records = test[testIndex + 2];
        for (var recordIndex = 0; recordIndex < records.length; recordIndex += 2) {
            var fragType = records[recordIndex];
            if (!typeof fragType == 'number' || fragType < 1 || recType > SORT_CUBIC) {
                console.log("unknown in range frag type: " + fragType);
                throw "stop execution";
            }
            var frags = records[recordIndex + 1];
            var first = 0;
            var last = -1;
            var first2 = 0;
            var last2 = 0;
            switch (recType) {
                case REC_TYPE_COMPUTED:
                case REC_TYPE_PATH:
                    switch (fragType) {
                        case PATH_LINE:
                            last = 4;
                            break;
                        case PATH_QUAD:
                            last = 6;
                            break;
                        case PATH_CUBIC:
                            last = 8;
                            break;
                        default:
                            console.log("unknown " + (recType == REC_TYPE_PATH ? "REC_TYPE_PATH" 
                                    : "REC_TYPE_COMPUTED") + " frag type:" + fragType);
                            throw "stop execution";
                    }
                    break;
                case REC_TYPE_ACTIVE:
                    first = 1;
                    switch (fragType) {
                        case ACTIVE_LINE_SPAN:
                            last = 5;
                            break;
                        case ACTIVE_QUAD_SPAN:
                            last = 7;
                            break;
                        case ACTIVE_CUBIC_SPAN:
                            last = 9;
                            break;
                        default:
                            console.log("unknown REC_TYPE_ACTIVE frag type: " + fragType);
                            throw "stop execution";
                    }
                    break;
                case REC_TYPE_ADD:
                    switch (fragType) {
                        case ADD_MOVETO:
                            last = 2;
                            break;
                        case ADD_LINETO:
                            last = 2;
                            break;
                        case ADD_QUADTO:
                            last = 4;
                            break;
                        case ADD_CUBICTO:
                            last = 6;
                            break;
                        case ADD_CLOSE:
                            break;
                        default:
                            console.log("unknown REC_TYPE_ADD frag type: " + fragType);
                            throw "stop execution";
                    }
                    break;
                case REC_TYPE_SECT:
                    switch (fragType) {
                        case INTERSECT_LINE:
                            first = 1; last = 5; first2 = 8; last2 = 12;
                            break;
                        case INTERSECT_LINE_2:
                            first = 1; last = 5; first2 = 11; last2 = 15;
                            break;
                        case INTERSECT_LINE_NO:
                            first = 0; last = 4; first2 = 4; last2 = 8;
                            break;
                        case INTERSECT_QUAD_LINE:
                            first = 1; last = 7; first2 = 10; last2 = 14;
                            break;
                        case INTERSECT_QUAD_LINE_2:
                            first = 1; last = 7; first2 = 13; last2 = 17;
                            break;
                        case INTERSECT_QUAD_LINE_NO:
                            first = 0; last = 6; first2 = 6; last2 = 10;
                            break;
                        case INTERSECT_QUAD:
                            first = 1; last = 7; first2 = 10; last2 = 16;
                            break;
                        case INTERSECT_QUAD_2:
                            first = 1; last = 7; first2 = 13; last2 = 19;
                            break;
                        case INTERSECT_QUAD_NO:
                            first = 0; last = 6; first2 = 6; last2 = 12;
                            break;
                        case INTERSECT_SELF_CUBIC:
                            first = 1; last = 9;
                            break;
                        case INTERSECT_SELF_CUBIC_NO:
                            first = 0; last = 8;
                            break;
                        case INTERSECT_CUBIC_LINE:
                            first = 1; last = 9; first2 = 12; last2 = 16;
                            break;
                        case INTERSECT_CUBIC_LINE_2:
                            first = 1; last = 9; first2 = 15; last2 = 19;
                            break;
                        case INTERSECT_CUBIC_LINE_3:
                            first = 1; last = 9; first2 = 18; last2 = 22;
                            break;
                        case INTERSECT_CUBIC_LINE_NO:
                            first = 0; last = 8; first2 = 8; last2 = 12;
                            break;
                        case INTERSECT_CUBIC:
                            first = 1; last = 9; first2 = 12; last2 = 20;
                            break;
                        case INTERSECT_CUBIC_2:
                            first = 1; last = 9; first2 = 15; last2 = 23;
                            break;
                        case INTERSECT_CUBIC_3:
                            first = 1; last = 9; first2 = 18; last2 = 26;
                            break;
                        case INTERSECT_CUBIC_4:
                            first = 1; last = 9; first2 = 21; last2 = 29;
                            break;
                        case INTERSECT_CUBIC_NO:
                            first = 0; last = 8; first2 = 8; last2 = 16;
                            break;
                        default:
                            console.log("unknown REC_TYPE_SECT frag type: " + fragType);
                            throw "stop execution";
                    }
                    break;
                default:
                    continue;
            }
            for (var idx = first; idx < last; idx += 2) {
                xmin = Math.min(xmin, frags[idx]);
                xmax = Math.max(xmax, frags[idx]);
                ymin = Math.min(ymin, frags[idx + 1]);
                ymax = Math.max(ymax, frags[idx + 1]);
            }
            for (var idx = first2; idx < last2; idx += 2) {
                xmin = Math.min(xmin, frags[idx]);
                xmax = Math.max(xmax, frags[idx]);
                ymin = Math.min(ymin, frags[idx + 1]);
                ymax = Math.max(ymax, frags[idx + 1]);
            }
        }
    }
    setScale();
}

function setScale() {
    var srcWidth = xmax - xmin;
    var srcHeight = ymax - ymin;
    var hscale = ctx.canvas.width / srcWidth;
    var vscale = ctx.canvas.height / srcHeight;
    scale = Math.min(hscale, vscale);
    var invScale = 1 / scale;
    var sxmin = xmin - invScale * 5;
    var symin = ymin - invScale * 10;
    var sxmax = xmax + invScale * (6 * decimal_places + 10);
    var symax = ymax + invScale * 10;
    srcWidth = sxmax - sxmin;
    srcHeight = symax - symin;
    hscale = ctx.canvas.width / srcWidth;
    vscale = ctx.canvas.height / srcHeight;
    scale = Math.min(hscale, vscale);
    srcLeft = sxmin;
    srcTop = symin;
}

function drawPoint(px, py) {
    for (var pts = 0; pts < drawnPts.length; pts += 2) {
        var x = drawnPts[pts];
        var y = drawnPts[pts + 1];
        if (px == x && py == y) {
            return;
        }
    }
    drawnPts.push(px);
    drawnPts.push(py);
    var label = px.toFixed(decimal_places) + ", " + py.toFixed(decimal_places);
    var _px = (px - srcLeft)* scale;
    var _py = (py - srcTop) * scale;
    ctx.beginPath();
    ctx.arc(_px, _py, 3, 0, Math.PI*2, true);
    ctx.closePath();
    ctx.fill();
    ctx.fillText(label, _px + 5, _py);
}

function drawPoints(ptArray, curveType) {
    var count = (curveType - PATH_LINE + 2) * 2;
    for (var idx = 0; idx < count; idx += 2) {
        drawPoint(ptArray[idx], ptArray[idx + 1]);
    }
}

function drawControlLines(curve, curveType) {
    if (curveType == PATH_LINE) {
        return;
    }
    ctx.strokeStyle = "rgba(0,0,0, 0.3)";
    drawLine(curve[0], curve[1], curve[2], curve[3]);
    drawLine(curve[2], curve[3], curve[4], curve[5]);
    if (curveType == PATH_CUBIC)
        drawLine(curve[4], curve[5], curve[4], curve[5]);
}

function drawPointAtT(curve, curveType) {
    var x, y;
    var t = curveT;
    switch (curveType) {
        case PATH_LINE:
            var a = 1 - t;
            var b = t;
            x = a * curve[0] + b * curve[2];
            y = a * curve[1] + b * curve[3];
            break;
        case PATH_QUAD:
            var one_t = 1 - t;
            var a = one_t * one_t;
            var b = 2 * one_t * t;
            var c = t * t;
            x = a * curve[0] + b * curve[2] + c * curve[4];
            y = a * curve[1] + b * curve[3] + c * curve[5];
            break;
        case PATH_CUBIC:
            var one_t = 1 - t;
            var one_t2 = one_t * one_t;
            var a = one_t2 * one_t;
            var b = 3 * one_t2 * t;
            var t2 = t * t;
            var c = 3 * one_t * t2;
            var d = t2 * t;
            x = a * curve[0] + b * curve[2] + c * curve[4] + d * curve[6];
            y = a * curve[1] + b * curve[3] + c * curve[5] + d * curve[7];
            break;
    }
    drawPoint(x, y);
    if (!draw_intersectT) {
        return;
    }
    ctx.fillStyle = "red";
    drawTAtPointUp(x, y, curveT);
}

function drawTAtPointUp(px, py, t) {
    var label = t.toFixed(decimal_places);
    var _px = (px - srcLeft)* scale;
    var _py = (py - srcTop) * scale;
    ctx.fillText(label, _px + 5, _py - 10);
}

function drawTAtPointDown(px, py, t) {
    var label = t.toFixed(decimal_places);
    var _px = (px - srcLeft)* scale;
    var _py = (py - srcTop) * scale;
    ctx.fillText(label, _px + 5, _py + 10);
}

function drawLine(x1, y1, x2, y2) {
    for (var pts = 0; pts < drawnLines.length; pts += 4) {
        if (x1 == drawnLines[pts] && y1 == drawnLines[pts + 1]) {
            return;
        }
        if (x2 == drawnLines[pts + 2] && y2 == drawnLines[pts + 3]) {
            return;
        }
    }
    drawnLines.push(x1);
    drawnLines.push(y1);
    drawnLines.push(x2);
    drawnLines.push(y2);
    ctx.beginPath();
    ctx.moveTo((x1 - srcLeft) * scale,
            (y1 - srcTop) * scale);
    ctx.lineTo((x2 - srcLeft) * scale,
            (y2 - srcTop) * scale);
    ctx.stroke();
}

function drawLinePartial(x1, y1, x2, y2, t1, t2) {
    var dx = x1 - x2;
    var dy = y1 - y2;
    var ax = x1 - t1 * dx;
    var ay = y1 - t1 * dy;
    var bx = x1 - t2 * dx;
    var by = y1 - t2 * dy;
    ctx.beginPath();
    ctx.moveTo((ax - srcLeft) * scale,
            (ay - srcTop) * scale);
    ctx.lineTo((bx - srcLeft) * scale,
            (by - srcTop) * scale);
    ctx.stroke();
}

function drawQuad(x1, y1, x2, y2, x3, y3) {
    for (var pts = 0; pts < drawnQuads.length; pts += 6) {
        if (x1 == drawnQuads[pts] && y1 == drawnQuads[pts + 1]) {
            return;
        }
        if (x2 == drawnQuads[pts + 2] && y2 == drawnQuads[pts + 3]) {
            return;
        }
        if (x3 == drawnQuads[pts + 4] && x3 == drawnQuads[pts + 5]) {
            return;
        }
    }
    drawnQuads.push(x1);
    drawnQuads.push(y1);
    drawnQuads.push(x2);
    drawnQuads.push(y2);
    drawnQuads.push(x3);
    drawnQuads.push(y3);
    ctx.beginPath();
    ctx.moveTo((x1 - srcLeft) * scale,
            (y1 - srcTop) * scale);
    ctx.quadraticCurveTo((x2 - srcLeft) * scale,
            (y2 - srcTop) * scale,
            (x3 - srcLeft) * scale,
            (y3 - srcTop) * scale);
    ctx.stroke();
}

function interp(A, B, t) {
    return A + (B - A) * t;
}

function interp_quad_coords(x1, x2, x3, t)
{
    var ab = interp(x1, x2, t);
    var bc = interp(x2, x3, t);
    var abc = interp(ab, bc, t);
    return abc;
}

function drawQuadPartial(x1, y1, x2, y2, x3, y3, t1, t2) {
    var ax = interp_quad_coords(x1, x2, x3, t1);
    var ay = interp_quad_coords(y1, y2, y3, t1);
    var dx = interp_quad_coords(x1, x2, x3, (t1 + t2) / 2);
    var dy = interp_quad_coords(y1, y2, y3, (t1 + t2) / 2);
    var cx = interp_quad_coords(x1, x2, x3, t2);
    var cy = interp_quad_coords(y1, y2, y3, t2);
    var bx = 2*dx - (ax + cx)/2;
    var by = 2*dy - (ay + cy)/2;
    ctx.beginPath();
    ctx.moveTo((ax - srcLeft) * scale,
            (ay - srcTop) * scale);
    ctx.quadraticCurveTo((bx - srcLeft) * scale,
            (by - srcTop) * scale,
            (cx - srcLeft) * scale,
            (cy - srcTop) * scale);
    ctx.stroke();
}

function drawCubic(x1, y1, x2, y2, x3, y3, x4, y4) {
    for (var pts = 0; pts < drawnCubics.length; pts += 8) {
        if (x1 == drawnCubics[pts] && y1 == drawnCubics[pts + 1]) {
            return;
        }
        if (x2 == drawnCubics[pts + 2] && y2 == drawnCubics[pts + 3]) {
            return;
        }
        if (x3 == drawnCubics[pts + 4] && y3 == drawnCubics[pts + 5]) {
            return;
        }
        if (x4 == drawnCubics[pts + 6] && y4 == drawnCubics[pts + 7]) {
            return;
        }
    }
    drawnCubics.push(x1);
    drawnCubics.push(y1);
    drawnCubics.push(x2);
    drawnCubics.push(y2);
    drawnCubics.push(x3);
    drawnCubics.push(y3);
    drawnCubics.push(x4);
    drawnCubics.push(y4);
    ctx.beginPath();
    ctx.moveTo((x1 - srcLeft) * scale,
            (y1 - srcTop) * scale);
    ctx.bezierCurveTo((x2 - srcLeft) * scale,
            (y2 - srcTop) * scale,
            (x3 - srcLeft) * scale,
            (y3 - srcTop) * scale,
            (x4 - srcLeft) * scale,
            (y4 - srcTop) * scale);
    ctx.stroke();
}

function interp_cubic_coords(x1, x2, x3, x4, t)
{
    var ab = interp(x1, x2, t);
    var bc = interp(x2, x3, t);
    var cd = interp(x3, x4, t);
    var abc = interp(ab, bc, t);
    var bcd = interp(bc, cd, t);
    var abcd = interp(abc, bcd, t);
    return abcd;
}

function drawCubicPartial(x1, y1, x2, y2, x3, y3, x4, y4, t1, t2) {
    var ax = interp_cubic_coords(x1, x2, x3, x4, t1);
    var ay = interp_cubic_coords(y1, y2, y3, y4, t1);
    var ex = interp_cubic_coords(x1, x2, x3, x4, (t1*2+t2)/3);
    var ey = interp_cubic_coords(y1, y2, y3, y4, (t1*2+t2)/3);
    var fx = interp_cubic_coords(x1, x2, x3, x4, (t1+t2*2)/3);
    var fy = interp_cubic_coords(y1, y2, y3, y4, (t1+t2*2)/3);
    var dx = interp_cubic_coords(x1, x2, x3, x4, t2);
    var dy = interp_cubic_coords(y1, y2, y3, y4, t2);
    var mx = ex * 27 - ax * 8 - dx;
    var my = ey * 27 - ay * 8 - dy;
    var nx = fx * 27 - ax - dx * 8;
    var ny = fy * 27 - ay - dy * 8;
    var bx = (mx * 2 - nx) / 18;
    var by = (my * 2 - ny) / 18;
    var cx = (nx * 2 - mx) / 18;
    var cy = (ny * 2 - my) / 18;
    ctx.beginPath();
    ctx.moveTo((ax - srcLeft) * scale,
            (ay - srcTop) * scale);
    ctx.bezierCurveTo((bx - srcLeft) * scale,
            (by - srcTop) * scale,
            (cx - srcLeft) * scale,
            (cy - srcTop) * scale,
            (dx - srcLeft) * scale,
            (dy - srcTop) * scale,
            (ex - srcLeft) * scale,
            (ey - srcTop) * scale);
    ctx.stroke();
}

function draw(test, lines, title) {
    ctx.fillStyle = "rgba(0,0,0, 0.1)";
    ctx.font = "normal 50px Arial";
    ctx.fillText(title, 50, 50);
    ctx.font = "normal 10px Arial";
    ctx.lineWidth = "1.001"; "0.999";
    var moveX, moveY;
    var secondPath = test.length;
    var closeCount = 0;
    var logStart = -1;
    var logRange = 0;
    // find last active rec type at this step
    var curType = test[0];
    var curStep = 0;
    var lastIndex = test.length - 1;
    var hasOp = false;
    var lastActive = 0;
    var lastSort = 0;
    var lastMark = 0;
    var activeCount = 0;
    var sortCount = 0;
    var markCount = 0;
    for (var testIndex = 0; testIndex < test.length; testIndex += 3) {
        var recType = test[testIndex];
        if (!typeof recType == 'number' || recType < REC_TYPE_UNKNOWN || recType > REC_TYPE_LAST) {
            console.log("unknown rec type: " + recType);
            throw "stop execution";
        }
   //     if (curType == recType && curType != REC_TYPE_ADD) {
   //         continue;
   //     }
        if (step_limit > 0 && curStep >= step_limit) {
            break;
        }
        curType = recType;
        if (recType == REC_TYPE_OP) {
            hasOp = true;
            continue;
        }
        if (recType == REC_TYPE_SECT || recType == REC_TYPE_UNKNOWN) {
            // these types do not advance step
            continue;
        }
        if (recType == REC_TYPE_ADD) {
            var records = test[testIndex + 2];
            if (records.length != 2) {
                console.log("expect only two elements: " + records.length);
                throw "stop execution";
            }
            var fragType = records[0];
            if (fragType == ADD_MOVETO || fragType == ADD_CLOSE) {
                continue;
            }
            if (!draw_add) {
                continue;
            }
        }
        if ((recType == REC_TYPE_PATH || recType == REC_TYPE_COMPUTED) && hasOp) {
            secondPath = testIndex;
        }
        if (recType == REC_TYPE_ACTIVE) {
            if (!draw_active) {
                continue;
            }
            lastActive = testIndex;
            ++activeCount;
        }
        if (recType == REC_TYPE_SORT) {
            if (!draw_sort) {
                continue;
            }
            lastSort = testIndex;
            ++sortCount;
        }
        if (recType = REC_TYPE_MARK) {
            if (!draw_mark) {
                continue;
            }
            lastMark = testIndex;
            ++markCount;
        }
        lastIndex = testIndex;
        ++curStep;
    }
    drawnPts = [];
    drawnLines = [];
    drawnQuads = [];
    drawnCubics = [];
    var opLetter = 'S';
    for (var testIndex = 0; testIndex <= lastIndex; testIndex += 3) {
        var recType = test[testIndex];
        logStart = test[testIndex + 1];
        var records = test[testIndex + 2];
        logRange = records.length / 2;
        for (var recordIndex = 0; recordIndex < records.length; recordIndex += 2) {
            var fragType = records[recordIndex];
            if (!typeof fragType == 'number' || fragType < 1 || recType > SORT_CUBIC) {
                console.log("unknown in range frag type: " + fragType);
                throw "stop execution";
            }
            var frags = records[recordIndex + 1];
            switch (recType) {
                case REC_TYPE_COMPUTED:
                    if (draw_computed == 0) {
                        continue;
                    }
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = testIndex < secondPath ? "black" : "red";
                    ctx.fillStyle = "blue";
                    switch (fragType) {
                        case PATH_QUAD:
                            if (draw_computed & 1) {
                                drawQuad(frags[0], frags[1], frags[2], frags[3],
                                        frags[4], frags[5]);
                            }
                            break;
                        case PATH_CUBIC:
                            if (draw_computed & 2) {
                                drawCubic(frags[0], frags[1], frags[2], frags[3],
                                        frags[4], frags[5], frags[6], frags[7]);
                            }
                            break;
                        default:
                            console.log("unknown REC_TYPE_COMPUTED frag type: " + fragType);
                            throw "stop execution";
                    }
                    if ((draw_computed & (fragType - PATH_LINE)) == 0) {
                        break;
                    }
                    if (pt_labels) {
                        drawPoints(frags, fragType);
                    }
                    if (control_lines) {
                        drawControlLines(frags, fragType);
                    }
                    if (curve_t) {
                        drawPointAtT(frags, fragType);
                    }
                    break;
                case REC_TYPE_PATH:
                    if (!draw_path) {
                        continue;
                    }
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = testIndex < secondPath ? "black" : "red";
                    ctx.fillStyle = "blue";
                    switch (fragType) {
                        case PATH_LINE:
                            drawLine(frags[0], frags[1], frags[2], frags[3]);
                            break;
                        case PATH_QUAD:
                            drawQuad(frags[0], frags[1], frags[2], frags[3],
                                    frags[4], frags[5]);
                            break;
                        case PATH_CUBIC:
                            drawCubic(frags[0], frags[1], frags[2], frags[3],
                                    frags[4], frags[5], frags[6], frags[7]);
                            break;
                        default:
                            console.log("unknown REC_TYPE_PATH frag type: " + fragType);
                            throw "stop execution";
                    }
                    if (pt_labels) {
                        drawPoints(frags, fragType);
                    }
                    if (control_lines) {
                        drawControlLines(frags, fragType);
                    }
                    if (curve_t) {
                        drawPointAtT(frags, fragType);
                    }
                    break;
                case REC_TYPE_OP:
                    switch (fragType) {
                        case OP_INTERSECT: opLetter = 'I'; break;
                        case OP_DIFFERENCE: opLetter = 'D'; break;
                        case OP_UNION: opLetter = 'U'; break;
                        case OP_XOR: opLetter = 'X'; break;
                        default:
                            console.log("unknown REC_TYPE_OP frag type: " + fragType);
                            throw "stop execution";
                    }
                    break;
                case REC_TYPE_ACTIVE:
                    if (!draw_active || testIndex < lastActive) {
                        continue;
                    }
                    var x1 = frags[SPAN_X1];
                    var y1 = frags[SPAN_Y1];
                    var x2 = frags[SPAN_X2];
                    var y2 = frags[SPAN_Y2];
                    var x3, y3, x3, y4, t1, t2;
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = "rgba(0,0,255, 0.3)";
                    switch (fragType) {
                        case ACTIVE_LINE_SPAN:
                            t1 = frags[SPAN_L_T];
                            t2 = frags[SPAN_L_TEND];
                            drawLinePartial(x1, y1, x2, y2, t1, t2);
                            break;
                        case ACTIVE_QUAD_SPAN:
                            x3 = frags[SPAN_X3];
                            y3 = frags[SPAN_Y3];
                            t1 = frags[SPAN_Q_T];
                            t2 = frags[SPAN_Q_TEND];
                            drawQuadPartial(x1, y1, x2, y2, x3, y3, t1, t2);
                            break;
                        case ACTIVE_CUBIC_SPAN:
                            x3 = frags[SPAN_X3];
                            y3 = frags[SPAN_Y3];
                            x4 = frags[SPAN_X4];
                            y4 = frags[SPAN_Y4];
                            t1 = frags[SPAN_C_T];
                            t2 = frags[SPAN_C_TEND];
                            drawCubicPartial(x1, y1, x2, y2, x3, y3, x4, y4, t1, t2);
                            break;
                        default:
                            console.log("unknown REC_TYPE_ACTIVE frag type: " + fragType);
                            throw "stop execution";
                    }
                    break;
                case REC_TYPE_ADD:
                    if (!draw_add) {
                        continue;
                    }
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = closeCount == 0 ? "rgba(0,0,255, 0.3)"
                            : closeCount == 1 ? "rgba(0,127,0, 0.3)"
                            : closeCount == 2 ? "rgba(0,127,127, 0.3)"
                            : closeCount == 3 ? "rgba(127,127,0, 0.3)"
                            : "rgba(127,0,127, 0.3)";
                    switch (fragType) {
                        case ADD_MOVETO:
                            moveX = frags[0];
                            moveY = frags[1];
                            break;
                        case ADD_LINETO:
                            drawLine(moveX, moveY, frags[0], frags[1], true);
                            moveX = frags[0];
                            moveY = frags[1];
                           break;
                        case ADD_QUADTO:
                            drawQuad(moveX, moveY, frags[0], frags[1], frags[2], frags[3], true);
                            moveX = frags[2];
                            moveY = frags[3];
                            break;
                        case ADD_CUBICTO:
                            drawCubic(moveX, moveY, frags[0], frags[1], frags[2], frags[3],
                                    frags[4], frags[5], true);
                            moveX = frags[4];
                            moveY = frags[5];
                            break;
                        case ADD_CLOSE:
                            ++closeCount;
                            break;
                        default:
                            console.log("unknown REC_TYPE_ADD frag type: " + fragType);
                            throw "stop execution";
                    }
                    break;
                case REC_TYPE_SECT:
                    if (!draw_intersection) {
                        continue;
                    }
                    ctx.lineWidth = 1;
                    ctx.strokeStyle = "rgba(0,0,255, 0.3)";
                    ctx.fillStyle = "blue";
                    var f = [];
                    switch (fragType) {
                        case INTERSECT_LINE:
                            f.push(5, 6, 0, 7);
                            break;
                        case INTERSECT_LINE_2:
                            f.push(5, 6, 0, 10);
                            f.push(8, 9, 7, 15);
                            break;
                        case INTERSECT_LINE_NO:
                            break;
                        case INTERSECT_QUAD_LINE:
                            f.push(7, 8, 0, 9);
                            break;
                        case INTERSECT_QUAD_LINE_2:
                            f.push(7, 8, 0, 12);
                            f.push(10, 11, 9, 17);
                            break;
                        case INTERSECT_QUAD_LINE_NO:
                            break;
                        case INTERSECT_QUAD:
                            f.push(7, 8, 0, 9);
                            break;
                        case INTERSECT_QUAD_2:
                            f.push(7, 8, 0, 12);
                            f.push(10, 11, 9, 19);
                            break;
                        case INTERSECT_QUAD_NO:
                            break;
                        case INTERSECT_SELF_CUBIC:
                            f.push(9, 10, 0, 11);
                            break;
                        case INTERSECT_SELF_CUBIC_NO:
                            break;
                        case INTERSECT_CUBIC_LINE:
                            f.push(9, 10, 0, 11);
                            break;
                        case INTERSECT_CUBIC_LINE_2:
                            f.push(9, 10, 0, 14);
                            f.push(12, 13, 11, 19);
                            break;
                        case INTERSECT_CUBIC_LINE_3:
                            f.push(9, 10, 0, 17);
                            f.push(12, 13, 11, 22);
                            f.push(15, 16, 14, 23);
                            break;
                        case INTERSECT_CUBIC_LINE_NO:
                            break;
                        case INTERSECT_CUBIC:
                            f.push(9, 10, 0, 11);
                            break;
                        case INTERSECT_CUBIC_2:
                            f.push(9, 10, 0, 14);
                            f.push(12, 13, 11, 23);
                            break;
                        case INTERSECT_CUBIC_3:
                            f.push(9, 10, 0, 17);
                            f.push(12, 13, 11, 26);
                            f.push(15, 16, 14, 27);
                            break;
                        case INTERSECT_CUBIC_4:
                            f.push(9, 10, 0, 20);
                            f.push(12, 13, 11, 29);
                            f.push(15, 16, 14, 30);
                            f.push(18, 19, 17, 31);
                            break;
                        case INTERSECT_CUBIC_NO:
                            break;
                        default:
                            console.log("unknown REC_TYPE_SECT frag type: " + fragType);
                            throw "stop execution";
                    }
                    for (var idx = 0; idx < f.length; idx += 4) {
                        drawPoint(frags[f[idx]], frags[f[idx + 1]]);
                    }
                    if (!draw_intersectT) {
                        break;
                    }
                    ctx.fillStyle = "red";
                    for (var idx = 0; idx < f.length; idx += 4) {
                        drawTAtPointUp(frags[f[idx]], frags[f[idx + 1]], frags[f[idx + 2]]);
                        drawTAtPointDown(frags[f[idx]], frags[f[idx + 1]], frags[f[idx + 3]]);
                    }
                    break;
                case REC_TYPE_SORT:
                    if (!draw_sort || testIndex < lastSort) {
                        continue;
                    }
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = "rgba(127,127,0, 0.5)";
                    switch (fragType) {
                        case SORT_LINE:
                            drawLinePartial(frags[1], frags[2], frags[3], frags[4],
                                frags[5], frags[6]);
                            break;
                        case SORT_QUAD:
                            drawQuadPartial(frags[1], frags[2], frags[3], frags[4],
                                frags[5], frags[6], frags[7], frags[8]);
                            break;
                        case SORT_CUBIC:
                            drawCubicPartial(frags[1], frags[2], frags[3], frags[4],
                                frags[5], frags[6], frags[7], frags[8], frags[9], frags[10]);
                            break;
                    }
                    break;
                case REC_TYPE_MARK:
                    if (!draw_mark || testIndex < lastMark) {
                        continue;
                    }
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = fragType >= MARK_DONE_LINE ?
                            "rgba(127,0,127, 0.5)" : "rgba(127,127,0, 0.5)";
                    switch (fragType) {
                        case MARK_LINE:
                            drawLinePartial(frags[1], frags[2], frags[3], frags[4],
                                frags[5], frags[9]);
                            break;
                        case MARK_QUAD:
                            drawQuadPartial(frags[1], frags[2], frags[3], frags[4],
                                frags[5], frags[6], frags[7], frags[11]);
                            break;
                        case MARK_CUBIC:
                            drawCubicPartial(frags[1], frags[2], frags[3], frags[4],
                                frags[5], frags[6], frags[7], frags[8], frags[9], frags[13]);
                            break;
                        case MARK_DONE_LINE:
                            drawLinePartial(frags[1], frags[2], frags[3], frags[4],
                                frags[5], frags[9]);
                            break;
                        case MARK_DONE_QUAD:
                            drawQuadPartial(frags[1], frags[2], frags[3], frags[4],
                                frags[5], frags[6], frags[7], frags[11]);
                            break;
                        case MARK_DONE_CUBIC:
                            drawCubicPartial(frags[1], frags[2], frags[3], frags[4],
                                frags[5], frags[6], frags[7], frags[8], frags[9], frags[13]);
                            break;
                    }
                    break;
                default:
                    continue;
            }
        }
    }
    if (draw_log && logStart >= 0) {
        ctx.font = "normal 10px Arial";
        ctx.beginPath();
        ctx.rect(50,550, 200,30);
        ctx.fillStyle = "white";
        ctx.fill();
        ctx.fillStyle = "rgba(0,0,0, 0.5)";
        if (logStart > 0) {
            ctx.fillText(lines[logStart - 1], 50, 558);
        }
        ctx.fillStyle = "black";
        for (var idx = 0; idx < logRange; ++idx) {
            ctx.fillText(lines[logStart + idx], 50, 568 + 10 * idx);
        }
        ctx.fillStyle = "rgba(0,0,0, 0.5)";
        if (logStart + logRange < lines.length) {
            ctx.fillText(lines[logStart + logRange], 50, 568 + 10 * logRange);
        }
    }
    if (draw_legend) {
        var pos = 0;
        drawBox(pos++, "yellow", "black", opLetter, true, '');
        drawBox(pos++, "rgba(0,0,255, 0.3)", "black", "X", draw_intersection, intersectionKey);
        drawBox(pos++, "rgba(0,0,255, 0.3)", "black", "+", draw_add, addKey);
        drawBox(pos++, "rgba(0,0,255, 0.3)", "black", activeCount, draw_active, activeKey);
        drawBox(pos++, "rgba(127,127,0, 0.3)", "black", sortCount, draw_sort, sortKey);
        drawBox(pos++, "rgba(127,0,127, 0.3)", "black", markCount, draw_mark, markKey);
        drawBox(pos++, "black", "white", "P", draw_path, pathKey);
        var computedLabel = ['Q', 'Q', 'C', 'QC'];
        drawBox(pos++, "rgba(0,63,0, 0.7)", "white", (new Array('Q', 'Q', 'C', 'QC'))[draw_computed],
                draw_computed != 0, computedKey);
        drawBox(pos++, "green", "black", curStep, true, '');
        drawBox(pos++, "green", "black", step_limit, true, '');
        drawBox(pos++, "red", "black", lastIndex, true, '');
        drawBox(pos++, "red", "black", test.length - 1, true, '');
        if (curve_t) {
            drawCurveTControl();
        }
    }
}

function drawBox(y, backC, foreC, str, enable, label) {
    ctx.beginPath();
    ctx.fillStyle = backC;
    ctx.rect(ctx.canvas.width - 40, y * 50 + 50, 40, 30);
    ctx.fill();
    ctx.font = "normal 16px Arial";
    ctx.fillStyle = foreC;
    ctx.textAlign = "center";
    ctx.fillText(str, ctx.canvas.width - 20, y * 50 + 72);
    if (!enable) {
        ctx.fillStyle = "rgba(255,255,255, 0.5)";
        ctx.fill();
    }
    if (label != '') {
        ctx.font = "normal 9px Arial";
        ctx.fillStyle = "black";
        ctx.fillText(label, ctx.canvas.width - 47, y * 50 + 80);
    }
    ctx.textAlign = "left";
}

function drawCurveTControl() {
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(0,0,0, 0.3)";
    ctx.beginPath();
    ctx.rect(ctx.canvas.width - 80, 40, 28, ctx.canvas.height - 80);
    ctx.stroke();
    var ty = 40 + curveT * (ctx.canvas.height - 80);
    ctx.beginPath();
    ctx.moveTo(ctx.canvas.width - 80, ty);
    ctx.lineTo(ctx.canvas.width - 85, ty - 5);
    ctx.lineTo(ctx.canvas.width - 85, ty + 5);
    ctx.lineTo(ctx.canvas.width - 80, ty);
    ctx.fillStyle = "rgba(0,0,0, 0.6)";
    ctx.fill();
    var num = curveT.toFixed(decimal_places);
    ctx.font = "normal 10px Arial";
    ctx.fillText(num, ctx.canvas.width - 78, ty);
}

function ptInTControl() {
    var e = window.event;
	var tgt = e.target || e.srcElement;
    var left = tgt.offsetLeft;
    var top = tgt.offsetTop;
    var x = (e.clientX - left);
    var y = (e.clientY - top);
    if (x < ctx.canvas.width - 80 || x > ctx.canvas.width - 50) {
        return false;
    }
    if (y < 40 || y > ctx.canvas.height - 80) {
        return false;
    }
    curveT = (y - 40) / (ctx.canvas.height - 120);
    if (curveT < 0 || curveT > 1) {
        throw "stop execution";
    }
    return true;
}

function drawTop() {
    init(tests[testIndex]);
    redraw();
}

function redraw() {
    ctx.beginPath();
    ctx.fillStyle = "white";
    ctx.rect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.fill();
    draw(tests[testIndex], testLines[testIndex], testTitles[testIndex]);
}

var activeKey = 'a';
var addKey = 'd';
var centerKey = 'c';
var computedKey = 'q';
var computedBackKey = 'Q';
var controlLinesKey = 'v';
var curveTKey = 'u';
var intersectTKey = 't';
var intersectionKey = 'i';
var infoKey = 'f';
var logKey = 'l';
var markKey = 'm';
var nextBy10Key = 'N';
var nextKey = 'n';
var pathKey = 'b';
var previousBy10Key = 'P';
var previousKey = 'p';
var ptsKey = 'x';
var sortKey = 'o';
var stepBackKey = 'S';
var stepKey = 's';
var xyKey = 'y';

function doKeyPress(evt) {
    var char = String.fromCharCode(evt.charCode);
    switch (char) {
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        decimal_places = char - '0';
        redraw();
        break;
    case activeKey:
        draw_active ^= true;
        redraw(); 
        break;
    case centerKey:
        setScale();
        redraw(); 
        break;
    case controlLinesKey:
        control_lines ^= true;
        redraw(); 
        break;
    case curveTKey:
        curve_t ^= true;
        redraw();
        break;
    case computedBackKey:
        draw_computed = (draw_computed - 1) & 3; // four-state
        redraw(); 
        break;
    case computedKey:
        draw_computed = (draw_computed + 1) & 3; // four-state
        redraw(); 
        break;
    case pathKey:
        draw_path ^= true;
        redraw(); 
        break;
    case addKey:
        draw_add ^= true;
        redraw(); 
        break;
    case infoKey:
        info_mode ^= true;
        redraw();
        break;
    case intersectionKey:
        draw_intersection ^= true;
        redraw(); 
        break;
    case logKey:
        draw_log ^= true;
        redraw();
        break;
    case markKey:
        draw_mark ^= true;
        redraw();
        break;
    case nextBy10Key:
        testIndex += 9;
    case nextKey:
        if (++testIndex >= tests.length)
            testIndex = 0;
        drawTop();
        break;
    case previousBy10Key:
        testIndex -= 9;
    case previousKey:
        if (--testIndex < 0)
            testIndex = tests.length - 1;
        drawTop();
        break;
    case stepKey:
        step_limit++;
        redraw();
        break;
    case stepBackKey:
        step_limit--;
        if (step_limit < 0) {
            step_limit = 0;
        }
        redraw();
        break;
    case sortKey:
        draw_sort ^= true;
        redraw();
        break;
    case intersectTKey:
        draw_intersectT ^= true;
        redraw();
        break;
    case ptsKey:
        pt_labels ^= true;
        redraw();
        break;
    case xyKey:
        debug_xy ^= true;
        redraw();
        break;
    case '-':
        scale /= 2;
        calcLeftTop();
        redraw();
        break;
    case '=':
    case '+':
        scale *= 2;
        calcLeftTop();
        redraw();
        break;
    case '/':
    case '?':
        draw_legend ^= true;
        redraw();
        break;
    }
}

function calcXY() {
    var e = window.event;
	var tgt = e.target || e.srcElement;
    var left = tgt.offsetLeft;
    var top = tgt.offsetTop;
    mouseX = (e.clientX - left) / scale + srcLeft;
    mouseY = (e.clientY - top) / scale + srcTop;
}

function calcLeftTop() {
    srcLeft = mouseX - screenWidth / 2 / scale;
    srcTop = mouseY - screenHeight / 2 / scale;
}

function handleMouseClick() {
    if (!curve_t || !ptInTControl()) {
        calcXY();
        calcLeftTop();
    }
    redraw();
}

function handleMouseOver() {
    calcXY();
    if (!debug_xy) {
        return;
    }
    var num = mouseX.toFixed(decimal_places) + ", " + mouseY.toFixed(decimal_places);
    ctx.beginPath();
    ctx.rect(300,100,200,10);
    ctx.fillStyle="white";
    ctx.fill();
    ctx.fillStyle="black";
    ctx.fillText(num, 300, 108);
}

function start() {
    for (i = 0; i < testDivs.length; ++i) {
        var title = testDivs[i].id.toString();
        var str = testDivs[i].firstChild.data;
        parse_all(str, title);
 //       parse_debugShowActiveSpans(str, title);
 //       parse_intersections(str, title);
    }
    drawTop();
    window.addEventListener('keypress', doKeyPress, true);
    window.onresize = function() {
        drawTop();
    }
}

</script>
</head>

<body onLoad="start();">
<canvas id="canvas" width="750" height="500"
    onmousemove="handleMouseOver()"
    onclick="handleMouseClick()"
    ></canvas >
</body>
</html>
